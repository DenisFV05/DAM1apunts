http://localhost:8080/ords/sql-developer

hr oracle

system oracle ??

alter session set container = FREEPDB1;
create User botiga identified by botiga;
grant connect to botiga;
grant create session to botiga;
grant unlimited tablespace to botiga;
grant dba to botiga;
grant create view to botiga;
commit;

























Aquí tienes un documento completo con varios ejemplos comentados y listos para copiar en Visual Studio Code o en Google Docs. Los ejemplos están diseñados de acuerdo con los temas de tu examen: función (BD Botiga), procedimiento y paquete (BD HR). Puedes ajustar nombres, comentarios o parámetros si es necesario.

---

# CHEAT SHEET: PL/SQL - Funciones, Procedimientos y Paquetes

---

## PARTE 1: FUNCIONES (BD Botiga)

### Ejemplo 1.1: Contar Empleados de un Departamento  
Esta función recibe un código de departamento y devuelve la cantidad de empleados en ese departamento.

```sql
-- Función: contar_empleados
CREATE OR REPLACE FUNCTION contar_empleados(p_dept_id IN NUMBER) RETURN NUMBER IS
    v_total NUMBER;  -- Variable para guardar el número total de empleados
BEGIN
    SELECT COUNT(*)
      INTO v_total
      FROM employees
     WHERE department_id = p_dept_id;
    RETURN v_total;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN 0;
    WHEN OTHERS THEN
        RETURN -1;  -- Se retorna -1 en caso de error
END;
```

**Notas:**  
- Se utiliza `CREATE OR REPLACE FUNCTION` para definir la función.  
- El parámetro `p_dept_id` es de solo entrada (IN).  
- Se emplea `SELECT COUNT(*) INTO v_total` para obtener el resultado.  
- Se captura la excepción para no bloquear la ejecución del código en caso de error.

---

### Ejemplo 1.2: Calcular Bonus de Vendedor  
Esta función calcula el bonus de un vendedor en función de su cargo, el año de venta, y el número total de ventas. Solo calcula si el cargo es "Sales Manager" o "Sales Representative" y el año está dentro de un rango válido.

```sql
-- Función: bonus_vendedor
CREATE OR REPLACE FUNCTION bonus_vendedor(
    p_employee_id NUMBER,  -- ID del vendedor
    p_year        NUMBER   -- Año de las ventas
) RETURN NUMBER IS
    v_job_title    VARCHAR2(100);  -- Almacena el cargo del vendedor
    v_total_sales  NUMBER;          -- Total de ventas realizadas
    v_current_year NUMBER := EXTRACT(YEAR FROM SYSDATE);  -- Año actual
    v_bonus        NUMBER;          -- Calcula el bonus
BEGIN
    -- 1. Obtener el título del trabajo del empleado
    SELECT job_title INTO v_job_title
      FROM employees
     WHERE employee_id = p_employee_id;
    
    -- 2. Verificar si el cargo es adecuado
    IF v_job_title NOT IN ('Sales Manager', 'Sales Representative') THEN
        RETURN NULL;
    END IF;
    
    -- 3. Validar que el año esté en el rango permitido
    IF p_year < 2000 OR p_year > v_current_year THEN
        RETURN NULL;
    END IF;
    
    -- 4. Contar las ventas en el año indicado
    SELECT COUNT(*)
      INTO v_total_sales
      FROM orders
     WHERE salesman_id = p_employee_id
       AND EXTRACT(YEAR FROM order_date) = p_year;
    
    -- 5. Calcular el bonus
    v_bonus := v_total_sales * 150;  -- 150 por cada venta
    
    RETURN v_bonus;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN NULL;
    WHEN OTHERS THEN
        RETURN NULL;
END;
```

**Notas:**  
- Se comprueba el cargo del vendedor antes de proceder.  
- Se verifica que el año se encuentre entre 2000 y el año actual.  
- Se utiliza el multiplicador 150 para el cálculo del bonus.

---

## PARTE 2: PROCEDIMIENTOS (BD HR)

### Ejemplo 2.1: Actualizar Salario de un Empleado  
Este procedimiento actualiza el salario de un empleado sumándole un incremento dado. También realiza un COMMIT para salvar la transacción.

```sql
-- Procedimiento: actualizar_salario
CREATE OR REPLACE PROCEDURE actualizar_salario(
    p_emp_id    IN NUMBER,  -- ID del empleado
    p_increment IN NUMBER   -- Monto a incrementar
) IS
BEGIN
    UPDATE employees
       SET salary = salary + p_increment
     WHERE employee_id = p_emp_id;
    
    COMMIT;  -- Confirmar la transacción
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;  -- Si ocurre un error, se revierte la transacción
        DBMS_OUTPUT.PUT_LINE('Error al actualizar el salario del empleado ' || p_emp_id);
END;
```

**Notas:**  
- Se usa `UPDATE` para modificar el salario.  
- Se aplica `COMMIT` después de la actualización.  
- Existe manejo básico de errores con `EXCEPTION`.

---

### Ejemplo 2.2: Listar Empleados por Departamento  
Este procedimiento muestra, usando un cursor, todos los empleados de un departamento. Se verifica que el departamento exista y se despliegan los datos mediante `DBMS_OUTPUT`.

```sql
-- Procedimiento: listar_empleados_departamento
CREATE OR REPLACE PROCEDURE listar_empleados_departamento(p_dept_id IN NUMBER) IS
    v_dept_name departments.department_name%TYPE;
    v_emp_count NUMBER;
    
    CURSOR cur_empleados IS
        SELECT e.first_name, e.last_name,
               TO_CHAR(e.hire_date, 'DD-MM-YYYY') AS hire_date,
               j.job_title
          FROM employees e
          JOIN jobs j ON e.job_id = j.job_id
         WHERE e.department_id = p_dept_id;
BEGIN
    -- Verificar que el parámetro no sea NULL
    IF p_dept_id IS NULL THEN
        DBMS_OUTPUT.PUT_LINE('El departamento no puede ser NULL.');
        RETURN;
    END IF;
    
    -- Comprobar si existe el departamento
    BEGIN
        SELECT department_name INTO v_dept_name
          FROM departments
         WHERE department_id = p_dept_id;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE('No existe el departamento con ID ' || p_dept_id);
            RETURN;
    END;
    
    DBMS_OUTPUT.PUT_LINE('Departamento: ' || v_dept_name);
    DBMS_OUTPUT.PUT_LINE('---------------------------------');
    
    -- Contar número de empleados en el departamento
    SELECT COUNT(*)
      INTO v_emp_count
      FROM employees
     WHERE department_id = p_dept_id;
    
    IF v_emp_count = 0 THEN
        DBMS_OUTPUT.PUT_LINE('El departamento no tiene empleados.');
    ELSE
        -- Iterar y mostrar los empleados
        FOR emp IN cur_empleados LOOP
            DBMS_OUTPUT.PUT_LINE(emp.first_name || ' ' || emp.last_name || ' | ' ||
                                     emp.hire_date || ' | ' || emp.job_title);
        END LOOP;
    END IF;
END;
```

**Notas:**  
- Se valida que el parámetro no sea `NULL`.  
- Se utiliza un bloque anidado para obtener el nombre del departamento y capturar una excepción en caso de que no exista.  
- El cursor `cur_empleados` recorre y muestra cada registro, formateado a la salida con `DBMS_OUTPUT.PUT_LINE`.

---

## PARTE 3: PAQUETES (BD HR)

Agrupar funciones y procedimientos en un paquete facilita la organización del código.

### Ejemplo 3.1: Paquete para Gestión de Empleados  
Este paquete agrupa dos funcionalidades: incrementar el salario y obtener el salario actual de un empleado.

#### Especificación del Paquete

```sql
-- Especificación del paquete: gestio_empleats
CREATE OR REPLACE PACKAGE gestio_empleats AS
    -- Procedimiento para incrementar el salario
    PROCEDURE incrementar_salario(
        p_emp_id    IN NUMBER,
        p_increment IN NUMBER
    );
    
    -- Función para obtener el salario actual del empleado
    FUNCTION obtener_salario(
        p_emp_id IN NUMBER
    ) RETURN NUMBER;
END gestio_empleats;
/
```

#### Cuerpo del Paquete

```sql
-- Cuerpo del paquete: gestio_empleats
CREATE OR REPLACE PACKAGE BODY gestio_empleats AS
    PROCEDURE incrementar_salario(
        p_emp_id    IN NUMBER,
        p_increment IN NUMBER
    ) IS
    BEGIN
        UPDATE employees
           SET salary = salary + p_increment
         WHERE employee_id = p_emp_id;
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            DBMS_OUTPUT.PUT_LINE('Error incrementando salario para el empleado ' || p_emp_id);
    END incrementar_salario;
    
    FUNCTION obtener_salario(
        p_emp_id IN NUMBER
    ) RETURN NUMBER IS
        v_salary employees.salary%TYPE;
    BEGIN
        SELECT salary
          INTO v_salary
          FROM employees
         WHERE employee_id = p_emp_id;
        RETURN v_salary;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RETURN NULL;
        WHEN OTHERS THEN
            RETURN -1;
    END obtener_salario;
END gestio_empleats;
/
```

**Notas:**  
- En la especificación se definen las “firmas” públicas: el procedimiento `incrementar_salario` y la función `obtener_salario`.  
- En el cuerpo se implementa la lógica:
  - El procedimiento actualiza y confirma la operación con `COMMIT`.
  - La función obtiene y retorna el salario, controlando excepciones.  
- Asegúrate de respetar la firma declarada en la especificación.

---

# Consejos para el Examen

- **Copia y pega el contenido:** Puedes copiar todo este documento a tu editor favorito (Visual Studio Code o Google Docs) para tenerlo a mano durante el examen.  
- **Entiende cada línea:** No te limites a memorizar; trata de comprender la lógica para poder adaptar o reestructurar el código si te lo piden.  
- **Revisa errores de sintaxis:** Asegúrate de que las barras `/` y puntos y coma (`;`) estén en los lugares correctos.  
- **Prueba mentalmente el flujo:** Antes de copiar en el examen, revisa que cada bloque (función, procedimiento, paquete) tenga su parte declarativa, ejecutable y manejo de excepciones adecuado.  

---

Copia este documento en tu entorno de consulta y utiliza los ejemplos como referencia para comprender y repasar la estructura y la lógica de cada ejercicio. ¡Mucho éxito en tu examen!


















CREATE OR REPLACE FUNCTION calcular_descuento(p_total IN NUMBER) 
RETURN NUMBER 
IS
    v_descuento NUMBER;
BEGIN
    IF p_total > 100 THEN
        v_descuento := p_total * 0.1; -- 10% de descuento si el total es mayor que 100
    ELSE
        v_descuento := 0; -- Sin descuento
    END IF;
    RETURN v_descuento;
END;


CREATE OR REPLACE PROCEDURE actualizar_salario(p_id_empleado IN NUMBER, p_nuevo_salario IN NUMBER) 
IS
BEGIN
    UPDATE empleados
    SET salario = p_nuevo_salario
    WHERE id_empleado = p_id_empleado;
    COMMIT;
END;


CREATE OR REPLACE PACKAGE gestion_empleados AS
    FUNCTION obtener_salario(p_id_empleado IN NUMBER) RETURN NUMBER;
    PROCEDURE actualizar_direccion(p_id_empleado IN NUMBER, p_nueva_direccion IN VARCHAR2);
END gestion_empleados;

CREATE OR REPLACE PACKAGE BODY gestion_empleados AS
    FUNCTION obtener_salario(p_id_empleado IN NUMBER) RETURN NUMBER IS
        v_salario NUMBER;
    BEGIN
        SELECT salario INTO v_salario
        FROM empleados
        WHERE id_empleado = p_id_empleado;
        RETURN v_salario;
    END obtener_salario;

    PROCEDURE actualizar_direccion(p_id_empleado IN NUMBER, p_nueva_direccion IN VARCHAR2) IS
    BEGIN
        UPDATE empleados
        SET direccion = p_nueva_direccion
        WHERE id_empleado = p_id_empleado;
        COMMIT;
    END actualizar_direccion;
END gestion_empleados;























CREATE OR REPLACE TRIGGER trigger_salario
AFTER UPDATE ON employees
FOR EACH ROW
BEGIN
    INSERT INTO salario_changes (employee_id, old_salary, new_salary)
    VALUES (:OLD.employee_id, :OLD.salary, :NEW.salary);
END;







DECLARE
    -- Declaración del cursor
    CURSOR c_empleados IS
        SELECT id, nombre, salario FROM empleados WHERE salario > 3000;
    
    -- Variables para almacenar los valores de cada fila
    v_id empleados.id%TYPE;
    v_nombre empleados.nombre%TYPE;
    v_salario empleados.salario%TYPE;
BEGIN
    -- Abrir el cursor
    OPEN c_empleados;
    
    -- Recorrer las filas obtenidas con el cursor
    LOOP
        -- Obtener cada fila del cursor
        FETCH c_empleados INTO v_id, v_nombre, v_salario;
        
        -- Si no hay más filas, salir del bucle
        EXIT WHEN c_empleados%NOTFOUND;
        
        -- Procesar los datos
        DBMS_OUTPUT.PUT_LINE('Empleado: ' || v_nombre || ', Salario: ' || v_salario);
    END LOOP;
    
    -- Cerrar el cursor
    CLOSE c_empleados;
END;
































Estructura para una Función (Function)
sql
Copiar
Editar
CREATE OR REPLACE FUNCTION nombre_funcion (
    parametro1 IN tipo, 
    parametro2 IN tipo
) RETURN tipo_resultado IS
    -- Declaración de variables locales
    variable tipo;
BEGIN
    -- Cuerpo de la función
    SELECT columna INTO variable
    FROM tabla
    WHERE condicion;
    
    -- Retornar el resultado
    RETURN variable;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        -- Manejo de excepciones
        RETURN NULL;
    WHEN OTHERS THEN
        -- Manejo de otros errores
        RETURN NULL;
END;
Notas:

Cambia los nombres de las variables, tablas y condiciones por los que corresponden en el examen.

En la parte de excepciones puedes manejar errores comunes como NO_DATA_FOUND o OTHERS.

Estructura para un Procedimiento (Procedure)
sql
Copiar
Editar
CREATE OR REPLACE PROCEDURE nombre_procedimiento (
    parametro1 IN tipo, 
    parametro2 OUT tipo
) IS
BEGIN
    -- Cuerpo del procedimiento
    -- Aquí puedes poner un SELECT o lógica que modifique variables o tablas
    
    SELECT columna
    INTO parametro2
    FROM tabla
    WHERE condicion;

    -- Puedes usar DBMS_OUTPUT.PUT_LINE para imprimir resultados en consola
    DBMS_OUTPUT.PUT_LINE('Mensaje de salida');
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        -- Manejo de excepciones
        DBMS_OUTPUT.PUT_LINE('No se encontraron datos');
    WHEN OTHERS THEN
        -- Otro tipo de error
        DBMS_OUTPUT.PUT_LINE('Error desconocido');
END;
Notas:

El procedimiento no retorna un valor como la función, pero puedes usar parámetros IN y OUT para pasar información.

DBMS_OUTPUT.PUT_LINE sirve para imprimir mensajes durante la ejecución.

Estructura para un Paquete (Package)
Especificación del Paquete:
sql
Copiar
Editar
CREATE OR REPLACE PACKAGE nombre_paquete AS
    -- Declaración de procedimientos y funciones disponibles
    FUNCTION nombre_funcion(p_parametro IN tipo) RETURN tipo;
    PROCEDURE nombre_procedimiento(p_parametro IN tipo);
END nombre_paquete;
Cuerpo del Paquete:
sql
Copiar
Editar
CREATE OR REPLACE PACKAGE BODY nombre_paquete AS
    -- Implementación de la función
    FUNCTION nombre_funcion(p_parametro IN tipo) RETURN tipo IS
    BEGIN
        -- Lógica de la función
        RETURN resultado;
    END nombre_funcion;

    -- Implementación del procedimiento
    PROCEDURE nombre_procedimiento(p_parametro IN tipo) IS
    BEGIN
        -- Lógica del procedimiento
        DBMS_OUTPUT.PUT_LINE('Resultado: ' || p_parametro);
    END nombre_procedimiento;
END nombre_paquete;
Notas:

El paquete agrupa varias funciones y procedimientos relacionados.

La especificación define las funciones/procedimientos disponibles.

El cuerpo contiene la implementación.

Consultas comunes para usar dentro de funciones/procedimientos:
Obtener el nombre de un departamento:
sql
Copiar
Editar
SELECT department_name INTO v_department_name
FROM departments
WHERE department_id = p_id;
Contar el número de empleados en un departamento:
sql
Copiar
Editar
SELECT COUNT(*) INTO v_count
FROM employees
WHERE department_id = p_id;
Obtener el título del trabajo de un empleado:
sql
Copiar
Editar
SELECT job_title INTO v_job_title
FROM employees
WHERE employee_id = p_employee_id;
Uso de Excepciones:
sql
Copiar
Editar
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        -- No se encontraron datos
        RETURN NULL;
    WHEN OTHERS THEN
        -- Captura cualquier otro error
        RETURN NULL;
Notas:

Las excepciones ayudan a manejar posibles errores durante la ejecución de la consulta.



































































CREATE OR REPLACE FUNCTION calcular_comision_salesman (
    p_employee_id NUMBER,
    p_year        NUMBER
) RETURN NUMBER IS
    v_total_sales  NUMBER;             -- Total de importe vendido
    v_order_count  NUMBER;             -- Número de órdenes
    v_comision     NUMBER;             -- Comisión calculada
    v_rate         NUMBER;             -- Tasa de comisión
    v_job_title    VARCHAR2(100);
    v_current_year NUMBER := EXTRACT(YEAR FROM SYSDATE);
BEGIN
    -- 1. Validar el título del empleado
    SELECT job_title
      INTO v_job_title
      FROM employees
     WHERE employee_id = p_employee_id;
     
    IF v_job_title NOT IN ('Sales Manager', 'Sales Representative') THEN
        RETURN NULL;
    END IF;
    
    -- 2. Validar el año: debe estar entre 2000 y el año actual
    IF p_year > v_current_year OR p_year < 2000 THEN
        RETURN NULL;
    END IF;
    
    -- 3. Obtener el total de ventas y número de órdenes en el año indicado
    SELECT NVL(SUM(amount), 0), COUNT(*)
      INTO v_total_sales, v_order_count
      FROM orders
     WHERE salesman_id = p_employee_id
       AND EXTRACT(YEAR FROM order_date) = p_year;
    
    -- 4. Definir la tasa de comisión según el total vendido
    IF v_total_sales > 10000 THEN
        v_rate := 0.15;
    ELSIF v_total_sales > 5000 THEN
        v_rate := 0.10;
    ELSE
        v_rate := 0.05;
    END IF;
    
    -- 5. Calcular la comisión
    v_comision := v_total_sales * v_rate;
    
    RETURN v_comision;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN NULL;
    WHEN OTHERS THEN
        RETURN NULL;
END;
/
























CREATE OR REPLACE PROCEDURE generar_reporte_empleados_departamento(
    p_department_id IN departments.department_id%TYPE
) IS
    v_department_name departments.department_name%TYPE;
    v_total_empleados NUMBER;
    CURSOR c_empleados IS
        SELECT first_name, last_name, 
               TO_CHAR(hire_date, 'DD-MM-YYYY') AS hire_date, 
               job_title
          FROM employees
         WHERE department_id = p_department_id
         ORDER BY last_name;
BEGIN
    -- Validar que p_department_id no sea NULL
    IF p_department_id IS NULL THEN
        DBMS_OUTPUT.PUT_LINE('El ID del departamento no puede ser NULL.');
        RETURN;
    END IF;
    
    -- Verificar que el departamento exista
    BEGIN
        SELECT department_name INTO v_department_name
          FROM departments
         WHERE department_id = p_department_id;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE('Departamento no encontrado.');
            RETURN;
    END;
    
    -- Contar el número de empleados en el departamento
    SELECT COUNT(*) INTO v_total_empleados
      FROM employees
     WHERE department_id = p_department_id;
    
    -- Mostrar encabezado del reporte
    DBMS_OUTPUT.PUT_LINE('Reporte del Departamento: ' || v_department_name);
    DBMS_OUTPUT.PUT_LINE('---------------------------------------------------');
    
    IF v_total_empleados = 0 THEN
        DBMS_OUTPUT.PUT_LINE('No hay empleados en este departamento.');
    ELSE
        -- Recorrer el cursor y mostrar cada empleado en formato fijo
        FOR rec IN c_empleados LOOP
            DBMS_OUTPUT.PUT_LINE(
                RPAD(rec.first_name, 15) || 
                RPAD(rec.last_name, 15)  ||
                RPAD(rec.hire_date, 15)  ||
                rec.job_title
            );
        END LOOP;
        DBMS_OUTPUT.PUT_LINE('Total de empleados: ' || v_total_empleados);
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Se produjo un error: ' || SQLERRM);
END;
/
























CREATE OR REPLACE PACKAGE pkg_utilidades_hr AS
    FUNCTION normalizar_string(p_texto VARCHAR2, p_convertir BOOLEAN) RETURN VARCHAR2;
    FUNCTION obtener_nombre_completo(p_employee_id NUMBER) RETURN VARCHAR2;
    FUNCTION calcular_antiguedad(p_employee_id NUMBER) RETURN NUMBER;
END pkg_utilidades_hr;
/

CREATE OR REPLACE PACKAGE BODY pkg_utilidades_hr AS

    -- Función para normalizar una cadena
    FUNCTION normalizar_string(p_texto VARCHAR2, p_convertir BOOLEAN) RETURN VARCHAR2 IS
        v_resultado VARCHAR2(200) := '';
        v_palabra   VARCHAR2(50);
        v_temp      VARCHAR2(200);
        v_pos       NUMBER;
    BEGIN
        IF p_texto IS NULL THEN
            RETURN NULL;
        END IF;
        v_temp := TRIM(p_texto);
        LOOP
            v_pos := INSTR(v_temp, ' ');
            IF v_pos = 0 THEN
                v_palabra := v_temp;
            ELSE
                v_palabra := SUBSTR(v_temp, 1, v_pos - 1);
            END IF;
            
            IF p_convertir THEN
                -- INITCAP convierte la palabra: primera letra mayúscula, resto minúscula
                v_palabra := INITCAP(v_palabra);
            END IF;
            
            IF v_resultado IS NULL OR v_resultado = '' THEN
                v_resultado := v_palabra;
            ELSE
                v_resultado := v_resultado || ' ' || v_palabra;
            END IF;
            
            IF v_pos = 0 THEN
                EXIT;
            END IF;
            v_temp := LTRIM(SUBSTR(v_temp, v_pos + 1));
        END LOOP;
        RETURN v_resultado;
    END normalizar_string;
    
    -- Función que obtiene el nombre completo de un empleado
    FUNCTION obtener_nombre_completo(p_employee_id NUMBER) RETURN VARCHAR2 IS
        v_first_name employees.first_name%TYPE;
        v_last_name  employees.last_name%TYPE;
    BEGIN
        SELECT first_name, last_name
          INTO v_first_name, v_last_name
          FROM employees
         WHERE employee_id = p_employee_id;
         
        RETURN v_first_name || ' ' || v_last_name;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RETURN 'Empleado no encontrado';
    END obtener_nombre_completo;
    
    -- Función que calcula la antigüedad (en años) de un empleado
    FUNCTION calcular_antiguedad(p_employee_id NUMBER) RETURN NUMBER IS
        v_hire_date employees.hire_date%TYPE;
        v_anios NUMBER;
    BEGIN
        SELECT hire_date
          INTO v_hire_date
          FROM employees
         WHERE employee_id = p_employee_id;
         
        -- Calcular años completos entre la fecha actual y la fecha de contratación
        v_anios := TRUNC(MONTHS_BETWEEN(SYSDATE, v_hire_date) / 12);
        RETURN v_anios;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RETURN NULL;
    END calcular_antiguedad;

END pkg_utilidades_hr;
/
